// boot.cc
// c++ source code for creating boot.oct file using mkoctfile in Octave 
//
// boot.oct is a function file for generating balanced bootstrap sample indices
//
// USAGE
// bootsam = boot (n, nboot)
// bootsam = boot (n, nboot, u)
// bootsam = boot (n, nboot, u, w)
//
// INPUT VARIABLES
// n (short integer, int16) is the number of rows (of the data vector)
// nboot (integer, int32) is the number of bootstrap resamples
// u (boolean) for unbiased: false (for bootstrap) or true (for bootknife)
// w (integer, int32) is a weight vector of length n. 
//
// OUTPUT VARIABLE
// bootsam (short integer, int16) is an n x nboot matrix of bootstrap resamples
//
// NOTES
// Uniform random numbers are generated by the Mersenne Twister 19937 generator.
// u is an optional input argument. The default is false. If u is true then 
// the sample index for omission in each bootknife resample is selected 
// systematically. If the remaining number of bootknife resamples is not 
// divisible by the sample size (n), then the sample index omitted is  
// selected randomly. 
// w is an optional input argument. The default is a vector of length n with
// each element equal to nboot (i.e. uniform weighting). Each element of w
// is the number of times that the corresponding index is represented in 
// bootsam. For example, if the second element is 500, then the value 2 will 
// will be assigned to 500 elements within bootsam. The sum of w should equal 
// n * nboot.
//
// Author: Andrew Charles Penn (2022)

#include <octave/oct.h>
#include <random>
using namespace std;

DEFUN_DLD (boot, args, , 
           " Function file (boot.oct) for generating balanced bootstrap sample indices \n"\
           " \n"\
           " USAGE \n"\
           " bootsam = boot (n, nboot) \n"\
           " bootsam = boot (n, nboot, u) \n"\
           " bootsam = boot (n, nboot, u, w) \n"\
           " \n"\
           " INPUT VARIABLES \n"\
           " n (short integer, int16) is the number of rows (of the data vector) \n"\
           " nboot (integer, int32) is the number of bootstrap resamples \n"\
           " u (boolean) for unbiased: false (for bootstrap) or true (for bootknife) \n"\
           " w (integer, int32) is a weight vector of length n. \n"\
           " \n"\
           " OUTPUT VARIABLE \n"\
           " bootsam (short integer, int16) is an n x nboot matrix of bootstrap resamples \n"\
           " \n"\
           " NOTES \n"\
           " Uniform random numbers are generated by the Mersenne Twister 19937 generator. \n"\
           " u is an optional input argument. The default is false. If u is true then \n"\
           " the sample index for omission in each bootknife resample is selected \n"\
           " systematically. If the remaining number of bootknife resamples is not \n"\
           " divisible by the sample size (n), then the sample index omitted is \n"\
           " selected randomly. \n"\
           " w is an optional input argument. The default is a vector of length n with \n"\
           " each element equal to nboot (i.e. uniform weighting). Each element of w \n"\
           " is the number of times that the corresponding index is represented in \n"\
           " bootsam. For example, if the second element is 500, then the value 2 will \n"\
           " will be assigned to 500 elements within bootsam. The sum of w should equal \n"\
           " n * nboot. \n"\
           " \n"\
           " Author: Andrew Charles Penn (2022)")
 {

    // Input variables
    if (args.length () < 2) {
        error("function requires at least 2 scalar input arguments");
    }
    // First input argument
    const short int n = args(0).int_value ();
    if (args(0).numel() > 1) {
        error("the first input argument must be scalar");
    }
    if (n <= 0) {
        error("the first input argument must be a positive integer");
    }
    // Second input argument
    const int nboot = args(1).int_value ();
    if (args(1).numel() > 1) {
        error("the second input argument must be scalar");
    }
    if (nboot <= 0) {
        error("the second input argument must be a positive integer");
    }
    // Third input argument
    bool u;
    if (args.length () < 3) {
        u = false;
    } else {
        u = args(2).bool_value ();
    }
    
    // Declare variables
    dim_vector dv (n, nboot); 
    int16NDArray bootsam (dv);       // Array of bootstrap sample indices
    long int N = n * nboot;          // Total counts of all sample indices
    long int k;                      // Variable to store random number
    int d;                           // Counter for cumulative sum calculations
    int c[n];                        // Counter for each of the sample indices
    if (args.length () > 3) {
        // Assign user defined weights (counts)
        ColumnVector w = args(3).column_vector_value ();
        if (w.numel() != n) {
            error("weights must be a vector of length n");
        }
        double *ptrW = w.fortran_vec ();
        long int s = 0; 
        for (int i = 0; i < n ; i++)  {
            c[i] = *(ptrW + i);     // Set each element in c to the specified weight
            s += c[i];
        }
        if (s != N) {
            error("weights must add up to n * nboot");
        }   
    } else {
        // Assign weights (counts) for uniform sampling
        for (int i = 0; i < n ; i++) {   
            c[i] = nboot;            // Set each element in c to nboot
        }
    }
    bool LOO = false;                // Leave-one-out (LOO) flag for the current bootstrap iteration (remains false if u is false)
    int r = -1;                      // Sample index for LOO (remains -1 and is ignored if u is false)
    int m = 0;                       // Counter for LOO sample index r (remains 0 if u is false) 

    // Create pointer so that we can more rapidly access elements of bootsam
    octave_int<short> *ptr = bootsam.fortran_vec ();
    
    // Initialize random number generator
    random_device rd;
    seed_seq seed {rd(), rd(), rd(), rd()};
    mt19937 rng(seed);
    uniform_int_distribution<int> distr (0, n - 1);
    
    // Perform balanced sampling
    for (int b = 0; b < nboot ; b++) { 
        OCTAVE_QUIT; // Acknowledge the Control-C key sequence to quit function early
        if (u) {    
            if ((b / n) == (nboot / n)) {
                r = distr (rng);      // random
            } else {
                r = b - (b / n) * n;  // systematic
            }
        }
        for (int i = 0; i < n ; i++) {
            if (u) {
                if (c[r] < N) {       // Only LOO if sample index r doesn't account for all remaining sampling counts
                    m = c[r];
                    c[r] = 0;
                    LOO = true;
                }
            }
            uniform_int_distribution<int> distk (0, N - m - 1);
            k = distk (rng); 
            d = c[0];
            for (int j = 0; j < n ; j++) { 
                if (k < d) {
                    *(ptr + b * n + i) = j + 1;
                    c[j] -= 1;
                    N -= 1;
                    break;
                } else {
                    d += c[j + 1];
                }
            }
            if (LOO == true) {
                c[r] = m;
                m = 0;
                LOO = false;
            }
        }   
    }    

    return octave_value (bootsam);
} 
